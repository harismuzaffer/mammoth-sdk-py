"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from mammoth_analytics import errors, models, utils
from mammoth_analytics._hooks import HookContext
from mammoth_analytics.types import OptionalNullable, UNSET
from mammoth_analytics.utils import get_security_from_env
from mammoth_analytics.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Mapping, Optional


class ExternalKeys(BaseSDK):
    def get_by_workspace_id(
        self,
        *,
        workspace_id: int = 2,
        fields: Optional[str] = "__standard",
        limit: Optional[int] = 50,
        offset: Optional[int] = 0,
        sort: Optional[str] = "(id:asc)",
        key_type: OptionalNullable[models.FilterByKeyType] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ExternalKeysPaginated:
        r"""Get external keys of the given Workspace ID


        This endpoint fetches all external keys added as part of the given Workspace ID


        :param workspace_id: Workspace refers to a collection of projects. Workspace ID is unique identifier for workspace.
        :param fields: Fields to be returned in a comma-separated format. Check full mode for all fields.
        :param limit: Max number of result to return
        :param offset: Distance from the beginning of the list of results
        :param sort: Returned results are sorted by the combination of the given fields.
        :param key_type: Returns all tasks where key type matches the given type
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetKeysByWorkspaceIDRequest(
            workspace_id=workspace_id,
            fields=fields,
            limit=limit,
            offset=offset,
            sort=sort,
            key_type=key_type,
        )

        req = self._build_request(
            method="GET",
            path="/workspaces/{workspace_id}/external_keys",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetKeysByWorkspaceId",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ExternalKeysPaginated, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                errors.GetKeysByWorkspaceIDBadRequestUnion, http_res
            )
            raise errors.GetKeysByWorkspaceIDBadRequest(response_data, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.MammothAnalyticsDefaultError(
            "Unexpected response received", http_res
        )

    async def get_by_workspace_id_async(
        self,
        *,
        workspace_id: int = 2,
        fields: Optional[str] = "__standard",
        limit: Optional[int] = 50,
        offset: Optional[int] = 0,
        sort: Optional[str] = "(id:asc)",
        key_type: OptionalNullable[models.FilterByKeyType] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ExternalKeysPaginated:
        r"""Get external keys of the given Workspace ID


        This endpoint fetches all external keys added as part of the given Workspace ID


        :param workspace_id: Workspace refers to a collection of projects. Workspace ID is unique identifier for workspace.
        :param fields: Fields to be returned in a comma-separated format. Check full mode for all fields.
        :param limit: Max number of result to return
        :param offset: Distance from the beginning of the list of results
        :param sort: Returned results are sorted by the combination of the given fields.
        :param key_type: Returns all tasks where key type matches the given type
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetKeysByWorkspaceIDRequest(
            workspace_id=workspace_id,
            fields=fields,
            limit=limit,
            offset=offset,
            sort=sort,
            key_type=key_type,
        )

        req = self._build_request_async(
            method="GET",
            path="/workspaces/{workspace_id}/external_keys",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetKeysByWorkspaceId",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ExternalKeysPaginated, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                errors.GetKeysByWorkspaceIDBadRequestUnion, http_res
            )
            raise errors.GetKeysByWorkspaceIDBadRequest(response_data, http_res)
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.MammothAnalyticsDefaultError(
            "Unexpected response received", http_res
        )

    def add(
        self,
        *,
        workspace_id: int = 2,
        key_type: models.AddExternalKeySpecKeyType,
        key_name: str,
        secure_key: str,
        description: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ExternalKey:
        r"""Add external keys to access the intended services

        External keys that lets Mammoth to user certain services. User brings their own key to access the service e.g AI based rules need an Open AI key

        :param workspace_id: Workspace refers to a collection of projects. Workspace ID is unique identifier for workspace.
        :param key_type: Type of the external key e.g. open_ai
        :param key_name: A name to be associated with the key
        :param secure_key: The key value which will be used in the intended service
        :param description: Describe the purpose of the key and any added information related to it
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddExternalKeyRequest(
            workspace_id=workspace_id,
            add_external_key_spec=models.AddExternalKeySpec(
                key_type=key_type,
                key_name=key_name,
                description=description,
                secure_key=secure_key,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/workspaces/{workspace_id}/external_keys",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.add_external_key_spec,
                False,
                False,
                "json",
                models.AddExternalKeySpec,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AddExternalKey",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.ExternalKey, http_res)
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.MammothAnalyticsDefaultError(
            "Unexpected response received", http_res
        )

    async def add_async(
        self,
        *,
        workspace_id: int = 2,
        key_type: models.AddExternalKeySpecKeyType,
        key_name: str,
        secure_key: str,
        description: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ExternalKey:
        r"""Add external keys to access the intended services

        External keys that lets Mammoth to user certain services. User brings their own key to access the service e.g AI based rules need an Open AI key

        :param workspace_id: Workspace refers to a collection of projects. Workspace ID is unique identifier for workspace.
        :param key_type: Type of the external key e.g. open_ai
        :param key_name: A name to be associated with the key
        :param secure_key: The key value which will be used in the intended service
        :param description: Describe the purpose of the key and any added information related to it
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddExternalKeyRequest(
            workspace_id=workspace_id,
            add_external_key_spec=models.AddExternalKeySpec(
                key_type=key_type,
                key_name=key_name,
                description=description,
                secure_key=secure_key,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/workspaces/{workspace_id}/external_keys",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.add_external_key_spec,
                False,
                False,
                "json",
                models.AddExternalKeySpec,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="AddExternalKey",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.ExternalKey, http_res)
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.MammothAnalyticsDefaultError(
            "Unexpected response received", http_res
        )

    def delete(
        self,
        *,
        workspace_id: int = 2,
        key_id: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete an external key

        Delete an external key from the DB. Doesnt not delete the corresponding key from the service

        :param workspace_id: Workspace refers to a collection of projects. Workspace ID is unique identifier for workspace.
        :param key_id: Id of an external key
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteExternalKeyRequest(
            workspace_id=workspace_id,
            key_id=key_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/workspaces/{workspace_id}/external_keys/{key_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeleteExternalKey",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, ["200", "204"], "*"):
            return
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.MammothAnalyticsDefaultError(
            "Unexpected response received", http_res
        )

    async def delete_async(
        self,
        *,
        workspace_id: int = 2,
        key_id: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete an external key

        Delete an external key from the DB. Doesnt not delete the corresponding key from the service

        :param workspace_id: Workspace refers to a collection of projects. Workspace ID is unique identifier for workspace.
        :param key_id: Id of an external key
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteExternalKeyRequest(
            workspace_id=workspace_id,
            key_id=key_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/workspaces/{workspace_id}/external_keys/{key_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeleteExternalKey",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, ["200", "204"], "*"):
            return
        if utils.match_response(http_res, ["400", "401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.MammothAnalyticsDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.MammothAnalyticsDefaultError(
            "Unexpected response received", http_res
        )
